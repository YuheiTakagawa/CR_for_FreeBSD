#include <stdio.h>
#include <stdlib.h>
#include <elf.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>

#define __handle_elf handle_elf_x86_64

static const unsigned char elf_ident_64_le[] = {
	0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01,
};

FILE *fout;

#define pr_out(fmt, ...)	\
  do{	\
    if(fout)	\
      fprintf(fout, fmt, ##__VA_ARGS__);	\
  }while(0)

int __handle_elf(void *mem, size_t size){
	const char *symstrings = NULL;
	Elf64_Shdr *symtab_hdr = NULL;
	Elf64_Sym *symbols = NULL;
	Elf64_Ehdr *hdr = mem;

	Elf64_Shdr *strtab_hdr = NULL;
	Elf64_Shdr **sec_hdrs = NULL;
	const char *secstrings;

	size_t i, k, nr_gotpcrel = 0;
	int ret = -1;
	const char *name;

	sec_hdrs = malloc(sizeof(*sec_hdrs) * hdr->e_shnum);
	if(!sec_hdrs){
		printf("err: No memory for section headers\n");
		ret = -1;
	}

	for (i = 0; i < hdr->e_shnum; i++){
		Elf64_Shdr *sh = mem + hdr->e_shoff + hdr->e_shentsize*i;

		if(sh->sh_type == SHT_SYMTAB)
			symtab_hdr = sh;

		sec_hdrs[i] = sh;
	}

	strtab_hdr = sec_hdrs[symtab_hdr->sh_link];
	symbols = mem + symtab_hdr->sh_offset;
	symstrings = mem + symtab_hdr->sh_offset;
	pr_out("/* Autogenerated from %s */\n", "parasite");
	
	for(i = 0; i < symtab_hdr->sh_size / symtab_hdr->sh_entsize; i++){
		Elf64_Sym *sym = &symbols[i];
		Elf64_Shdr *sh_src;

		name = &symstrings[sym->st_name];

		if(!*name)
			continue;

		if(strncmp(name, "__export", 8))
			continue;
		if((sym->st_shndx && sym->st_shndx < hdr->e_shnum) ||
			sym->st_shndx == SHN_ABS){
			if(sym->st_shndx == SHN_ABS){
				sh_src = NULL;
			}else{
				sh_src = sec_hdrs[sym->st_shndx];
			}
			pr_out("#define %s_sym%s 0x%lx\n",
					"parasite", name, (unsigned long)(sym->st_value + (sh_src ? sh_src->sh_addr : 0)));
		}
	}

	pr_out("static const char %s_blob[] = {\n\t", "parasite");

	for (i = 0, k = 0; i < hdr->e_shnum; i++){
		Elf_Shdr *sh = sec_hdrs[i];
		unsigned char *shdata;
		size_t j;

		if(!(sh->sh_flags & SHF_ALLOC) || ! sh->sh_size)
			continue;

		shdata = mem + sh->sh_offset;

		for (; k < sh->sh_addr; k++){
			if(k && (k % 8) == 0)
				pr_out("\n\t");
			pr_out("0x00,");
		}

		for(j = 0; j < sh->sh_size; j++, k++){
			if(k && (k % 8) == 0)
				pr_out("\n\t");
			pr_out("0x%02x,", shdata[j]);
		}
	}
	pr_out("};\n");
}

int handle_binary(void *mem, size_t size){
	if(memcmp(mem, elf_ident_64_le, sizeof(elf_ident_64_le)) == 0)
		return handle_elf_x86_64(mem, size);
}

int main(int argc, char *argv[]){
	if(argc < 3){
		printf("usage: ./headgen <binary file path> <output path>\n");
	}
	int fd;
	void *mem;
	struct stat st;
	int ret;

	char *input_filename = argv[1];

	fd = open(input_filename, O_RDONLY);
	if(fd < 0){
		printf("Can't open file %s\n", input_filename);
		return -1;
	}

	if(fstat(fd, &st)){
		perror("fstat");
		goto err;
	}
	
	char *output_filename = argv[2];
	fout = fopen(output_filename, "w");
	if(fout == NULL){
		printf("Can't open %s", output_filename);
		goto err;
	}

	mem = mmap(NULL, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FILE, fd, 0);
	if(mem == MAP_FAILED){
		perror("mmap");
		return -1;
	}

	if(handle_binary(mem, st.st_size)){
		close(fd), fd = -1;
		goto err;
	}

	ret = 0;

err:
	if(fd >= 0)
		close(fd);
	return ret;
}
